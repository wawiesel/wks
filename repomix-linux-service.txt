This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: wks/api/service/_linux/_Impl.py, wks/api/service/_linux/_Data.py, wks/api/service/_linux/README.md, wks/api/service/Service.py, wks/api/service/ServiceConfig.py, wks/api/service/_AbstractImpl.py, tests/integration/test_linux_service_install.py, Dockerfile.test-linux-service, .github/workflows/test-linux-service.yml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.github/
  workflows/
    test-linux-service.yml
tests/
  integration/
    test_linux_service_install.py
wks/
  api/
    service/
      _linux/
        _Data.py
        _Impl.py
        README.md
      _AbstractImpl.py
      Service.py
      ServiceConfig.py
Dockerfile.test-linux-service
```

# Files

## File: wks/api/service/_linux/_Data.py
```python
"""Linux (systemd) specific service configuration data."""

from pydantic import BaseModel, ConfigDict, Field, field_validator


class _Data(BaseModel):
    """Linux systemd service configuration data."""

    model_config = ConfigDict(extra="forbid")

    unit_name: str = Field(..., description="Systemd unit name (e.g., 'wks.service')")
    enabled: bool = Field(..., description="Whether service should start automatically on boot")

    @field_validator("unit_name")
    @classmethod
    def validate_unit_name(cls, v: str) -> str:
        if not v:
            raise ValueError("service.data.unit_name is required when service.type is 'linux'")
        # Basic validation: should end with .service
        if not v.endswith(".service"):
            raise ValueError(f"service.data.unit_name must end with '.service' (e.g., 'wks.service'), got: {v!r}")
        # Basic validation: should be a valid systemd unit name
        if not v.replace(".service", "").replace("-", "").replace("_", "").isalnum():
            raise ValueError(
                f"service.data.unit_name must be a valid systemd unit name "
                f"(alphanumeric, hyphens, underscores), got: {v!r}"
            )
        return v
```

## File: wks/api/service/_linux/_Impl.py
```python
"""Linux service implementation - installs daemon as systemd user service."""

import shutil
import subprocess
from contextlib import suppress
from pathlib import Path
from typing import Any

from ...config.WKSConfig import WKSConfig
from .._AbstractImpl import _AbstractImpl
from ..ServiceConfig import ServiceConfig
from ._Data import _Data


class _Impl(_AbstractImpl):
    """Linux-specific service implementation using systemd user services."""

    @staticmethod
    def _get_systemd_user_dir() -> Path:
        """Get the systemd user directory for the current user."""
        return Path.home() / ".config" / "systemd" / "user"

    @staticmethod
    def _get_unit_path(unit_name: str) -> Path:
        """Get the systemd unit file path for a given unit name."""
        return _Impl._get_systemd_user_dir() / unit_name

    @staticmethod
    def _create_unit_content(_config: _Data, wksc_path: str, restrict_dir: Path | None = None) -> str:
        """Create systemd unit file content that runs 'wksc daemon start'.

        Args:
            _config: Service configuration data (unused in Linux implementation, kept for API consistency)
            wksc_path: Path to wksc CLI command
            restrict_dir: Optional directory to restrict monitoring to
        """
        # Working directory is always WKS_HOME
        working_directory = WKSConfig.get_home_dir()

        # Single standardized log file under WKS_HOME
        log_file = working_directory / "logs" / "service.log"

        # Ensure directories exist
        log_file.parent.mkdir(parents=True, exist_ok=True)
        working_directory.mkdir(parents=True, exist_ok=True)

        # Build ExecStart command - run 'wksc daemon start [--restrict-dir PATH]'
        exec_start = f"{wksc_path} daemon start"
        if restrict_dir is not None:
            restrict_path = str(restrict_dir.expanduser().resolve())
            exec_start += f" --restrict-dir {restrict_path}"

        unit = f"""[Unit]
Description=WKS Daemon Service
After=network.target

[Service]
Type=simple
ExecStart={exec_start}
WorkingDirectory={working_directory}
StandardOutput=append:{log_file}
StandardError=append:{log_file}
Restart=always
RestartSec=10

[Install]
WantedBy=default.target
"""
        return unit

    def __init__(self, service_config: ServiceConfig | None = None):
        """Initialize Linux service implementation.

        Args:
            service_config: Service configuration. If None, loads from WKSConfig.
        """
        if service_config is None:
            config = WKSConfig.load()
            service_config = config.service

        if not isinstance(service_config.data, _Data):
            raise ValueError("Linux service config data is required")
        self.config = service_config
        self._data: _Data = service_config.data

    def install_service(self, restrict_dir: Path | None = None) -> dict[str, Any]:
        """Install daemon as Linux systemd user service.

        The unit file runs 'wksc daemon start' which handles the actual filesystem monitoring.

        Args:
            restrict_dir: Optional directory to restrict monitoring to
        """
        # Find wksc command
        wksc_path = shutil.which("wksc")
        if not wksc_path:
            raise RuntimeError("wksc command not found in PATH. Ensure WKS is installed.")

        unit_path = self._get_unit_path(self._data.unit_name)
        unit_dir = unit_path.parent

        # Ensure systemd user directory exists
        unit_dir.mkdir(parents=True, exist_ok=True)

        # Create unit file content that runs 'wksc daemon start'
        unit_content = self._create_unit_content(self._data, wksc_path, restrict_dir=restrict_dir)

        # Write unit file
        unit_path.write_text(unit_content, encoding="utf-8")

        # Reload systemd daemon to pick up new unit
        try:
            subprocess.run(
                ["systemctl", "--user", "daemon-reload"],
                check=True,
                capture_output=True,
                text=True,
            )
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to reload systemd daemon: {e.stderr}") from e

        # Enable service if requested
        if self._data.enabled:
            try:
                subprocess.run(
                    ["systemctl", "--user", "enable", self._data.unit_name],
                    check=True,
                    capture_output=True,
                    text=True,
                )
            except subprocess.CalledProcessError as e:
                raise RuntimeError(f"Failed to enable service: {e.stderr}") from e

        return {
            "success": True,
            "type": "linux",
            "unit_name": self._data.unit_name,
            "unit_path": str(unit_path),
        }

    def uninstall_service(self) -> dict[str, Any]:
        """Uninstall daemon Linux systemd user service."""
        unit_path = self._get_unit_path(self._data.unit_name)

        # Stop and disable service
        with suppress(Exception):
            subprocess.run(
                ["systemctl", "--user", "stop", self._data.unit_name],
                check=False,
                capture_output=True,
                text=True,
            )
        with suppress(Exception):
            subprocess.run(
                ["systemctl", "--user", "disable", self._data.unit_name],
                check=False,
                capture_output=True,
                text=True,
            )

        # Remove unit file
        if unit_path.exists():
            unit_path.unlink()

        # Reload systemd daemon
        with suppress(Exception):
            subprocess.run(
                ["systemctl", "--user", "daemon-reload"],
                check=False,
                capture_output=True,
                text=True,
            )

        return {
            "success": True,
            "type": "linux",
            "unit_name": self._data.unit_name,
        }

    def get_service_status(self) -> dict[str, Any]:
        """Get daemon Linux systemd user service status."""
        unit_path = self._get_unit_path(self._data.unit_name)

        status: dict[str, Any] = {
            "installed": unit_path.exists(),
            "unit_path": str(unit_path),
        }

        if status["installed"]:
            try:
                # Check if service is active
                result = subprocess.run(
                    ["systemctl", "--user", "is-active", self._data.unit_name],
                    capture_output=True,
                    text=True,
                    check=False,
                )
                status["running"] = result.returncode == 0

                # Get PID if running
                if status["running"]:
                    pid_result = subprocess.run(
                        ["systemctl", "--user", "show", self._data.unit_name, "--property=MainPID", "--value"],
                        capture_output=True,
                        text=True,
                        check=False,
                    )
                    if pid_result.returncode == 0:
                        pid_str = pid_result.stdout.strip()
                        if pid_str and pid_str != "0":
                            with suppress(ValueError):
                                status["pid"] = int(pid_str)
            except Exception:
                pass

        return status

    def start_service(self) -> dict[str, Any]:
        """Start daemon via Linux systemctl."""
        unit_path = self._get_unit_path(self._data.unit_name)

        if not unit_path.exists():
            return {
                "success": False,
                "error": f"Service unit file not found at {unit_path}. Install the service first.",
            }

        try:
            subprocess.run(
                ["systemctl", "--user", "start", self._data.unit_name],
                check=True,
                capture_output=True,
                text=True,
            )
            # Verify service actually started by checking status
            import time

            time.sleep(0.5)  # Give service a moment to start
            status = self.get_service_status()
            if status.get("running"):
                return {
                    "success": True,
                    "type": "linux",
                    "unit_name": self._data.unit_name,
                    "pid": status.get("pid"),
                }
            else:
                log_path = WKSConfig.get_home_dir() / "logs" / "service.log"
                return {
                    "success": False,
                    "error": f"Service failed to start. Check logs at: {log_path}",
                }
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.strip() if e.stderr else "Unknown error"
            return {
                "success": False,
                "error": f"Failed to start service: {error_msg}",
            }

    def stop_service(self) -> dict[str, Any]:
        """Stop daemon via Linux systemctl."""
        try:
            subprocess.run(
                ["systemctl", "--user", "stop", self._data.unit_name],
                check=True,
                capture_output=True,
                text=True,
            )
            return {
                "success": True,
                "type": "linux",
                "unit_name": self._data.unit_name,
            }
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.strip() if e.stderr else ""
            # Check for common "not running" errors - treat as success (idempotent)
            if "not loaded" in error_msg.lower() or "not found" in error_msg.lower():
                return {
                    "success": True,
                    "type": "linux",
                    "unit_name": self._data.unit_name,
                    "note": "Service was not running (already stopped).",
                }
            return {
                "success": False,
                "error": f"Failed to stop service: {error_msg}" if error_msg else "Failed to stop service.",
            }
```

## File: wks/api/service/_linux/README.md
```markdown
# Linux (systemd) Backend Implementation

This directory contains the Linux-specific implementation of the service API using systemd user services for service management.

## Linux-Specific Details

**Service Management**: Linux uses systemd for service management. User services are defined via unit files in `~/.config/systemd/user/` and managed via `systemctl --user` commands.

## Implementation Strategy

### Service Management

The implementation uses systemd user services (`systemctl --user`) for service management. See `_Impl.py` for the actual implementation.

**Service Installation**: The service unit file is created in `~/.config/systemd/user/` and runs `wksc daemon start` which handles the actual filesystem monitoring.

**Event Handling**: Filesystem monitoring is handled by the daemon itself (via `wksc daemon start`), not by the service implementation. The service implementation only manages the systemd service lifecycle.

### Unit File Structure

The systemd unit file includes:
- `[Unit]`: Service description and dependencies
- `[Service]`: ExecStart command, working directory, logging, restart policy
- `[Install]`: Service enablement target

**Working Directory**: Always `WKS_HOME` (from `WKSConfig.get_home_dir()`)

**Logging**: Single standardized log file at `{WKS_HOME}/logs/service.log`

**Restart Policy**: `Restart=always` with `RestartSec=10` to automatically restart the service if it crashes

### Service Lifecycle

1. **Install**: Creates unit file, reloads systemd daemon, optionally enables service
2. **Uninstall**: Stops service, disables service, removes unit file, reloads systemd daemon
3. **Start**: Starts service via `systemctl --user start`
4. **Stop**: Stops service via `systemctl --user stop`
5. **Status**: Checks if unit file exists, if service is active, and retrieves PID if running
```

## File: wks/api/service/_AbstractImpl.py
```python
"""Abstract base class for service implementations (system service installers)."""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any


class _AbstractImpl(ABC):
    """Abstract base class for platform-specific service implementations.

    Services install and manage the daemon as a system service (launchd on macOS).
    The daemon itself handles filesystem monitoring via `wksc daemon start`.
    """

    @abstractmethod
    def install_service(self, restrict_dir: Path | None = None) -> dict[str, Any]:
        """Install daemon as system service.

        Args:
            restrict_dir: Optional directory to restrict monitoring to

        Returns:
            Dictionary with installation result (success, label, plist_path, etc.)
        """
        pass

    @abstractmethod
    def uninstall_service(self) -> dict[str, Any]:
        """Uninstall daemon system service.

        Returns:
            Dictionary with uninstallation result
        """
        pass

    @abstractmethod
    def get_service_status(self) -> dict[str, Any]:
        """Get daemon service status.

        Returns:
            Dictionary with service status information (installed, pid, etc.)
        """
        pass

    @abstractmethod
    def start_service(self) -> dict[str, Any]:
        """Start daemon via system service manager.

        Returns:
            Dictionary with start result
        """
        pass

    @abstractmethod
    def stop_service(self) -> dict[str, Any]:
        """Stop daemon via system service manager.

        Returns:
            Dictionary with stop result
        """
        pass
```

## File: wks/api/service/Service.py
```python
"""Service public API - installs and manages daemon as system service."""

import platform
from pathlib import Path
from typing import Any

from pydantic import BaseModel

from ..StageResult import StageResult
from . import ServiceStartOutput
from ._AbstractImpl import _AbstractImpl
from .ServiceConfig import _BACKEND_REGISTRY, ServiceConfig


class Service:
    """Public API for service operations."""

    def __init__(self, service_config: ServiceConfig):
        self.service_config = service_config
        self._impl: _AbstractImpl | None = None

    @staticmethod
    def detect_os() -> str:
        """Detect the current operating system and check if backend is supported.

        Returns:
            OS identifier string matching platform.system().lower() (e.g., "darwin", "linux", "windows")

        Raises:
            RuntimeError: If OS backend directory does not exist
        """
        from pathlib import Path

        system = platform.system().lower()
        backend_dir = Path(__file__).parent / f"_{system}"
        if not backend_dir.exists():
            raise RuntimeError(f"Unsupported operating system: {system} (backend directory not found: {backend_dir})")
        return system

    @staticmethod
    def validate_backend_type(
        result_obj: StageResult,
        backend_type: str,
        output_class: type["BaseModel"],
        status_field: str,
    ) -> bool:
        """Validate backend type and set error result if invalid.

        Args:
            result_obj: StageResult to update if validation fails
            backend_type: Backend type to validate
            output_class: Output schema class to instantiate
            status_field: Name of status field in output (e.g., "running", "stopped", "installed")

        Returns:
            True if valid, False if invalid (and result_obj is already set)
        """
        if backend_type not in _BACKEND_REGISTRY:
            error_msg = (
                f"Unsupported service backend type: {backend_type!r} (supported: {list(_BACKEND_REGISTRY.keys())})"
            )
            result_obj.result = f"Error: {error_msg}"
            result_obj.output = output_class(
                errors=[error_msg],
                warnings=[],
                message=error_msg,
                **{status_field: False},
            ).model_dump(mode="python")
            result_obj.success = False
            return False
        return True

    def start_via_service(self) -> BaseModel:
        """Start service via service manager.

        Returns:
            ServiceStartOutput schema object
        """
        result = self.start_service()
        if "success" not in result:
            raise KeyError("start_service() result missing required 'success' field")
        success = result["success"]

        if success:
            if "label" not in result:
                raise KeyError("start_service() result missing required 'label' field when success=True")
            message = f"Service started successfully (label: {result['label']})"
            errors = []
        else:
            if "error" not in result:
                raise KeyError("start_service() result missing required 'error' field when success=False")
            message = f"Error starting service: {result['error']}"
            errors = [result["error"]]

        return ServiceStartOutput(
            errors=errors,
            warnings=[],
            message=message,
            running=success,
        )

    def __enter__(self):
        backend_type = self.service_config.type

        # Validate backend type using DaemonConfig registry (single source of truth)
        backend_registry = _BACKEND_REGISTRY
        if backend_type not in backend_registry:
            raise ValueError(f"Unsupported backend type: {backend_type!r} (supported: {list(backend_registry.keys())})")

        # Import daemon implementation class directly from backend _Impl module
        module = __import__(f"wks.api.service._{backend_type}._Impl", fromlist=[""])
        impl_class = module._Impl
        self._impl = impl_class(self.service_config)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Daemon implementations don't need cleanup, but we keep the pattern for consistency
        return False

    def get_service_status(self) -> dict[str, Any]:
        """Get daemon service status.

        Returns:
            Dictionary with service status information (installed, pid, etc.)
        """
        if not self._impl:
            raise RuntimeError("Service not initialized. Use as context manager first.")
        return self._impl.get_service_status()

    def install_service(self, restrict_dir: Path | None = None) -> dict[str, Any]:
        """Install daemon as system service.

        The plist runs 'wksc daemon start' to handle filesystem monitoring.

        Args:
            restrict_dir: Optional directory to restrict monitoring to

        Returns:
            Dictionary with installation result (success, label, plist_path, etc.)
        """
        if not self._impl:
            raise RuntimeError("Service not initialized. Use as context manager first.")
        return self._impl.install_service(restrict_dir=restrict_dir)

    def uninstall_service(self) -> dict[str, Any]:
        """Uninstall system service.

        Returns:
            Dictionary with uninstallation result
        """
        if not self._impl:
            raise RuntimeError("Service not initialized. Use as context manager first.")
        return self._impl.uninstall_service()

    def start_service(self) -> dict[str, Any]:
        """Start service via system service manager.

        Returns:
            Dictionary with start result
        """
        if not self._impl:
            raise RuntimeError("Service not initialized. Use as context manager first.")
        return self._impl.start_service()

    def stop_service(self) -> dict[str, Any]:
        """Stop service via system service manager.

        Returns:
            Dictionary with stop result
        """
        if not self._impl:
            raise RuntimeError("Service not initialized. Use as context manager first.")
        return self._impl.stop_service()
```

## File: wks/api/service/ServiceConfig.py
```python
"""Service configuration with Pydantic validation."""

from typing import Any

from pydantic import BaseModel, Field, model_validator

from ._darwin._Data import _Data as _DarwinData
from ._linux._Data import _Data as _LinuxData

# Registry: add new backends here (ONLY place backend types are enumerated)
_BACKEND_REGISTRY: dict[str, type[BaseModel]] = {
    "darwin": _DarwinData,
    "linux": _LinuxData,
}


class ServiceConfig(BaseModel):
    """Service configuration with platform-specific data."""

    _BACKEND_REGISTRY: dict[str, type[BaseModel]] = _BACKEND_REGISTRY

    type: str = Field(..., description="Platform/service manager type")
    data: BaseModel = Field(..., description="Platform-specific configuration data")
    sync_interval_secs: float = Field(
        ...,
        gt=0,
        description=(
            "How long (in seconds) the daemon accumulates filesystem events before syncing them to the monitor database"
        ),
    )

    @model_validator(mode="before")
    @classmethod
    def validate_and_populate_data(cls, values: Any) -> dict[str, Any]:
        if not isinstance(values, dict):
            raise ValueError(f"service config must be a dict, got {type(values).__name__}")
        daemon_type = values.get("type")
        if not daemon_type:
            raise ValueError("service.type is required")
        # Access module-level registry (single source of truth)
        backend_registry = _BACKEND_REGISTRY
        config_data_class = backend_registry.get(daemon_type)
        if not config_data_class:
            raise ValueError(f"Unknown service type: {daemon_type!r} (supported: {list(backend_registry.keys())})")
        data_dict = values.get("data")
        if data_dict is None:
            raise ValueError("service.data is required")
        # Instantiate platform-specific config class
        values["data"] = config_data_class(**data_dict)
        return values

    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to properly serialize nested data model."""
        result = super().model_dump(**kwargs)
        # Explicitly serialize the data field since it's typed as BaseModel
        if isinstance(self.data, BaseModel):
            result["data"] = self.data.model_dump(**kwargs)
        return result
```

## File: tests/integration/test_linux_service_install.py
```python
"""Integration test for Linux systemd service installation.

This test runs in a Docker container with systemd to verify that the Linux
service backend can actually install, start, stop, and uninstall systemd user services.

Requires Docker and a systemd-enabled container image.
"""

import platform
import subprocess
from pathlib import Path

import pytest

from wks.api.config.WKSConfig import WKSConfig
from wks.api.service.Service import Service


def _check_systemd_available() -> bool:
    """Check if systemd is available (running in Docker with systemd).

    This check verifies that systemd is running and user services are available.
    """
    try:
        # First check if systemctl exists
        result = subprocess.run(
            ["systemctl", "--version"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode != 0:
            return False

        # Check if systemd is running (PID 1 check)
        try:
            init_process = Path("/proc/1/comm").read_text().strip()
            if init_process != "systemd":
                return False
        except Exception:
            return False

        # Check if user systemd session is available
        # Use list-units as it's more reliable than is-system-running for user services
        result = subprocess.run(
            ["systemctl", "--user", "list-units", "--no-pager"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        # If we can list units, systemd user session is working
        # Check for common errors in stderr
        if result.stderr:
            error_lower = result.stderr.lower()
            if (
                "failed to connect" in error_lower
                or "no such file" in error_lower
                or "connection refused" in error_lower
            ):
                return False
        # Return true if command succeeded (even if no units listed)
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


@pytest.mark.integration
@pytest.mark.linux_service
def test_linux_service_install_lifecycle(tmp_path, monkeypatch):
    """Test full lifecycle: install, start, status, stop, uninstall.

    This test REQUIRES systemd and must run on Linux (or in a Docker container with systemd enabled).
    On non-Linux platforms, this test is skipped (we test platform-specific code on the appropriate platform).
    """
    # Only run on Linux - test platform-specific code on the appropriate platform
    if platform.system() != "Linux":
        pytest.skip(f"Linux service tests only run on Linux (current platform: {platform.system()})")

    # On Linux, systemd must be available
    if not _check_systemd_available():
        pytest.fail(
            "systemd not available - this test requires systemd "
            "(run in Docker with systemd or on a Linux system with systemd)"
        )

    # Set up WKS_HOME
    wks_home = tmp_path / ".wks"
    wks_home.mkdir(parents=True, exist_ok=True)
    monkeypatch.setenv("WKS_HOME", str(wks_home))

    # Create minimal config with Linux service backend
    config_dict = {
        "monitor": {
            "filter": {
                "include_paths": [],
                "exclude_paths": [],
                "include_dirnames": [],
                "exclude_dirnames": [],
                "include_globs": [],
                "exclude_globs": [],
            },
            "priority": {
                "dirs": {},
                "weights": {
                    "depth_multiplier": 0.9,
                    "underscore_multiplier": 0.5,
                    "only_underscore_multiplier": 0.1,
                    "extension_weights": {},
                },
            },
            "database": "monitor",
            "sync": {
                "max_documents": 1000000,
                "min_priority": 0.0,
                "prune_interval_secs": 300.0,
            },
        },
        "database": {
            "type": "mongomock",
            "prefix": "wks",
            "data": {},
        },
        "service": {
            "type": "linux",
            "sync_interval_secs": 60.0,
            "data": {
                "unit_name": "wks-test-integration.service",
                "enabled": False,
            },
        },
        "daemon": {
            "sync_interval_secs": 0.1,
        },
    }

    config = WKSConfig.model_validate(config_dict)
    config.save()

    # Initialize service
    with Service(config.service) as service:
        # 1. Install service
        install_result = service.install_service()
        assert install_result["success"] is True
        assert install_result["type"] == "linux"
        assert install_result["unit_name"] == "wks-test-integration.service"
        assert Path(install_result["unit_path"]).exists()

        # 2. Check status (should be installed but not running)
        status = service.get_service_status()
        assert status["installed"] is True
        assert status.get("running", False) is False

        # 3. Start service
        start_result = service.start_service()
        if not start_result.get("success"):
            # Print error for debugging
            error_msg = start_result.get("error", "Unknown error")
            pytest.fail(f"Service start failed: {error_msg}")
        assert start_result["success"] is True

        # 4. Check status (should be running)
        status = service.get_service_status()
        assert status["installed"] is True
        assert status.get("running", False) is True

        # 5. Stop service
        stop_result = service.stop_service()
        assert stop_result["success"] is True

        # 6. Check status (should be installed but not running)
        status = service.get_service_status()
        assert status["installed"] is True
        assert status.get("running", False) is False

        # 7. Uninstall service
        uninstall_result = service.uninstall_service()
        assert uninstall_result["success"] is True

        # 8. Check status (should not be installed)
        status = service.get_service_status()
        assert status["installed"] is False
```

## File: Dockerfile.test-linux-service
```
# Dockerfile for testing Linux systemd service installation.
# Based on geerlingguy's proven systemd container setup for CI testing.
# Reference: https://github.com/geerlingguy/docker-ubuntu2404-ansible

FROM ubuntu:24.04

ARG DEBIAN_FRONTEND=noninteractive
ENV container=docker

# Install systemd and required dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    systemd \
    systemd-sysv \
    systemd-cron \
    libpam-systemd \
    rsyslog \
    dbus \
    dbus-user-session \
    python3 \
    python3-pip \
    python3-venv \
    git \
    sudo \
    iproute2 \
    ca-certificates \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# Remove unnecessary getty and udev targets that cause high CPU usage
# and aren't needed for testing (from geerlingguy's setup)
RUN rm -f /lib/systemd/system/systemd*udev* \
    && rm -f /lib/systemd/system/getty.target

# Create a non-root user for testing
RUN useradd -m -s /bin/bash testuser && \
    echo "testuser ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers && \
    mkdir -p /home/testuser/.config/systemd/user && \
    chown -R testuser:testuser /home/testuser

WORKDIR /workspace

ENV WKS_HOME=/home/testuser/.wks
ENV PATH=/home/testuser/.local/bin:$PATH

# Volumes for systemd (from geerlingguy's setup)
VOLUME ["/sys/fs/cgroup", "/tmp", "/run"]

# Use systemd as init
CMD ["/lib/systemd/systemd"]
```

## File: .github/workflows/test-linux-service.yml
```yaml
name: Test Linux Service Installation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-linux-service:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image with systemd
        run: |
          docker build \
            -f Dockerfile.test-linux-service \
            -t wks-test-linux-service:latest \
            .

      - name: Run Linux service integration test
        run: |
          # Run container with systemd support
          # Based on geerlingguy's proven approach:
          # https://github.com/geerlingguy/docker-ubuntu2404-ansible
          CONTAINER_ID=$(docker run -d \
            --privileged \
            --cgroupns=host \
            --volume=/sys/fs/cgroup:/sys/fs/cgroup:rw \
            --volume "${{ github.workspace }}:/workspace:rw" \
            --workdir /workspace \
            -e WKS_HOME=/home/testuser/.wks \
            wks-test-linux-service:latest)

          echo "Container ID: $CONTAINER_ID"

          # Wait for systemd to boot
          echo "Waiting for systemd to initialize..."
          sleep 10

          # Check if container is running
          CONTAINER_STATUS=$(docker inspect -f '{{.State.Running}}' $CONTAINER_ID 2>/dev/null || echo "false")
          if [ "$CONTAINER_STATUS" != "true" ]; then
            echo "Container stopped unexpectedly. Logs:"
            docker logs $CONTAINER_ID 2>&1 || true
            echo "Inspect:"
            docker inspect $CONTAINER_ID | head -50 || true
            exit 1
          fi
          echo "Container is running"

          # Verify systemd is running
          echo "Checking systemd status..."
          docker exec $CONTAINER_ID systemctl is-system-running --wait || docker exec $CONTAINER_ID systemctl status || true

          # Set up XDG_RUNTIME_DIR for testuser
          echo "Setting up user runtime directory..."
          docker exec $CONTAINER_ID bash -c '
            USER_ID=$(id -u testuser)
            mkdir -p /run/user/$USER_ID
            chown testuser:testuser /run/user/$USER_ID
            chmod 700 /run/user/$USER_ID
          '

          # Enable lingering for testuser (required for user services)
          echo "Enabling linger..."
          docker exec $CONTAINER_ID loginctl enable-linger testuser || true

          # Wait a bit for systemd-logind to process the linger
          sleep 3

          # Check if user service is now running
          echo "Checking if user@testuser.service is active..."
          docker exec $CONTAINER_ID systemctl status user@$(docker exec $CONTAINER_ID id -u testuser).service || true

          # If not active, start it explicitly
          docker exec $CONTAINER_ID systemctl start user@$(docker exec $CONTAINER_ID id -u testuser).service || true

          # Wait for user systemd session to be ready
          echo "Waiting for user systemd session..."
          for i in {1..30}; do
            if docker exec $CONTAINER_ID sudo -u testuser bash -c 'export XDG_RUNTIME_DIR=/run/user/$(id -u) && systemctl --user list-units --no-pager' >/dev/null 2>&1; then
              echo "User systemd session is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Warning: User systemd session may not be ready"
              # Show debug info
              docker exec $CONTAINER_ID ls -la /run/user/ || true
              docker exec $CONTAINER_ID cat /run/user/$(docker exec $CONTAINER_ID id -u testuser)/bus 2>&1 || true
            fi
            sleep 1
          done

          # Run the test inside the container using dbus-run-session
          # This provides a D-Bus session for systemctl --user without needing cgroup delegation
          docker exec $CONTAINER_ID sudo -u testuser bash -c '
            set -e
            export WKS_HOME=/home/testuser/.wks
            export PATH=/home/testuser/.local/bin:$PATH
            export XDG_RUNTIME_DIR=/run/user/$(id -u)

            # Debug: Check systemd status
            echo "=== Debug: systemd check ==="
            systemctl --version || echo "systemctl not found"
            cat /proc/1/comm || echo "cant read /proc/1/comm"

            # Check user bus socket
            echo "Checking for user bus..."
            ls -la /run/user/$(id -u)/ 2>&1 || echo "No user runtime dir"

            # Try running systemctl --user with dbus-run-session
            echo "Testing systemctl --user with dbus-run-session..."
            dbus-run-session -- systemctl --user list-units --no-pager 2>&1 || echo "dbus-run-session approach also failed"

            cd /workspace
            sudo chown -R testuser:testuser /workspace || true
            echo "Upgrading pip..."
            python3 -m pip install --user --upgrade pip --break-system-packages
            echo "Installing package..."
            pip3 install --user -e . --break-system-packages
            echo "Running tests..."
            # Run with dbus-run-session wrapper for the whole test
            dbus-run-session -- python3 -m pytest tests/integration/test_linux_service_install.py -v -m linux_service
          ' 2>&1
          EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "Test failed with exit code $EXIT_CODE"
            echo "Container logs:"
            docker logs $CONTAINER_ID 2>&1 | tail -100 || true
          fi

          # Cleanup
          docker stop $CONTAINER_ID || true
          docker rm $CONTAINER_ID || true
          exit $EXIT_CODE
```
