#!/usr/bin/env python3
"""Pre-commit hook to validate vault links before committing.

This hook checks all staged markdown files for broken links and prevents
commits if broken links are found.

Installation:
    Copy or symlink to .git/hooks/pre-commit and make executable:
    chmod +x .git/hooks/pre-commit
"""

import sys
import subprocess
from pathlib import Path
from typing import List, Set, Tuple
import os

# Try to find and use WKS venv if available
WKS_VENV_PYTHON = Path.home() / "2025-WKS" / ".venv" / "bin" / "python3"
if WKS_VENV_PYTHON.exists() and sys.executable != str(WKS_VENV_PYTHON):
    # Re-exec with venv Python if not already using it
    os.execv(str(WKS_VENV_PYTHON), [str(WKS_VENV_PYTHON), __file__])


def get_staged_markdown_files(vault_path: Path) -> List[Path]:
    """Get list of staged markdown files.

    Args:
        vault_path: Path to vault root

    Returns:
        List of absolute paths to staged .md files
    """
    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "--diff-filter=ACM"],
            cwd=vault_path,
            capture_output=True,
            text=True,
            timeout=5,
        )

        if result.returncode != 0:
            return []

        files = []
        for line in result.stdout.splitlines():
            if line.endswith(".md"):
                file_path = vault_path / line.strip()
                if file_path.exists():
                    files.append(file_path)

        return files

    except Exception:
        return []


def check_vault_links(vault_path: Path, files: List[Path]) -> Tuple[bool, List[str]]:
    """Check links in staged files.

    Args:
        vault_path: Path to vault root
        files: List of markdown files to check

    Returns:
        Tuple of (all_valid, error_messages)
    """
    # Import WKS modules
    try:
        sys.path.insert(0, str(vault_path.parent / "2025-WKS"))
        from wks.vault.markdown_parser import parse_wikilinks, parse_markdown_urls
        from wks.vault.link_resolver import LinkResolver
    except ImportError as exc:
        return False, [f"Failed to import WKS modules: {exc}"]

    errors = []
    links_dir = vault_path / "_links"
    resolver = LinkResolver(links_dir)

    for file_path in files:
        try:
            text = file_path.read_text(encoding="utf-8")
            relative_path = file_path.relative_to(vault_path)

            # Check wikilinks
            for link in parse_wikilinks(text):
                metadata = resolver.resolve(link.target)
                if metadata.status == "missing_target":
                    errors.append(
                        f"{relative_path}:{link.line_number}: "
                        f"Broken wikilink [[{link.target}]]"
                    )

            # Check markdown URLs (file:// only - external http/https are allowed to be offline)
            for url_link in parse_markdown_urls(text):
                if url_link.url.startswith("file://"):
                    # Parse file:// URL to path
                    import urllib.parse
                    parsed = urllib.parse.urlparse(url_link.url)
                    target_path = Path(parsed.path)

                    if not target_path.exists():
                        errors.append(
                            f"{relative_path}:{url_link.line_number}: "
                            f"Broken file:// URL: {url_link.url}"
                        )

        except Exception as exc:
            errors.append(f"{file_path}: Failed to check links: {exc}")

    return len(errors) == 0, errors


def main() -> int:
    """Main hook entry point.

    Returns:
        0 if validation passed, 1 if validation failed
    """
    # Get vault path (current directory for the hook)
    vault_path = Path.cwd()

    # Check if we're in a git repo
    try:
        subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            cwd=vault_path,
            capture_output=True,
            check=True,
            timeout=5,
        )
    except Exception:
        print("ERROR: Not in a git repository", file=sys.stderr)
        return 1

    # Get staged markdown files
    staged_files = get_staged_markdown_files(vault_path)

    if not staged_files:
        # No markdown files staged, allow commit
        return 0

    print(f"Validating links in {len(staged_files)} staged markdown file(s)...")

    # Validate links
    all_valid, errors = check_vault_links(vault_path, staged_files)

    if all_valid:
        print("✓ All links valid")
        return 0

    # Print errors
    print(f"\n✗ Found {len(errors)} broken link(s):\n", file=sys.stderr)
    for error in errors:
        print(f"  {error}", file=sys.stderr)

    print(
        "\nCommit aborted. Fix broken links before committing.\n"
        "To skip validation, use: git commit --no-verify",
        file=sys.stderr,
    )

    return 1


if __name__ == "__main__":
    sys.exit(main())
